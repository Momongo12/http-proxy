# HTTP Proxy

## Описание проекта

Данный проект реализует многопоточный HTTP/1.0 прокси-сервер на C++. Прокси принимает клиентские подключения по TCP, читает HTTP-запросы, подключается к целевым серверам, пересылает запросы и возвращает клиентам ответы.

Основные возможности:
- Обработка GET запросов.
- Поддержка перенаправлений (3xx).
- Многопоточность с пулом потоков для параллельной обработки нескольких клиентских соединений.
- Корректная обработка сигналов (SIGINT/SIGTERM) для graceful shutdown.
- CLI аргументы: `--port`, `--max-client-threads`, `--help`.
- Поддержка как относительных, так и полных URL.

## Структура проекта
```bash
http_proxy/
├─ CMakeLists.txt               // Файл сборки CMake
├─ include/
│  ├─ proxy_app.hpp             // Класс ProxyApp: точка запуска приложения
│  ├─ listener.hpp              // Класс Listener: прослушивание порта, accept подключений
│  ├─ thread_pool.hpp           // Класс ThreadPool: пул потоков для обработки клиентов
│  ├─ http_parser.hpp           // Класс HttpParser: парсинг HTTP запросов
│  ├─ connection_handler.hpp    // Класс ConnectionHandler: подключение к серверу, пересылка запроса, получение ответа
│  ├─ signal_handler.hpp        // Класс SignalHandler: обработка сигналов для graceful shutdown
│  ├─ logger.hpp                // Класс Logger: логирование
│  ├─ config.hpp                // Структура Config: хранение настроек (порт, число потоков)
│  ├─ utils.hpp                 // Utils: вспомогательные функции (trim, parseUrl)
│  └─ http_parser.hpp           // Парсер HTTP запросов
│
├─ src/
│  ├─ main.cpp                  // Точка входа
│  ├─ proxy_app.cpp             // Реализация ProxyApp
│  ├─ listener.cpp              // Реализация Listener
│  ├─ thread_pool.cpp           // Реализация ThreadPool и логики воркеров
│  ├─ http_parser.cpp           // Реализация HttpParser
│  ├─ connection_handler.cpp    // Реализация ConnectionHandler
│  ├─ signal_handler.cpp        // Реализация SignalHandler
│  ├─ logger.cpp                // Реализация Logger
│  └─ utils.cpp                 // Реализация утилитных функций (trim, parseUrl)
```


## Подробное описание классов

**ProxyApp**  
Основной класс приложения.
- Парсит аргументы командной строки (`--port`, `--max-client-threads`, `--help`).
- Инициализирует `Listener` для прослушивания порта.
- Создаёт и инициализирует `ThreadPool`.
- Устанавливает обработчики сигналов через `SignalHandler`.
- В методе `run()` использует `select()` для ожидания новых подключений и при появлении нового клиента передаёт сокет клиентского подключения в `ThreadPool`.
- По получению сигнала завершения корректно останавливает пул потоков и завершает приложение.

**Listener**  
Отвечает за сетевой ввод/вывод на стороне сервера (прокси):
- Создаёт TCP-сокет, связывает его с указанным портом и вызывает `listen()`.
- Переводит сокет в неблокирующий режим.
- Предоставляет метод `acceptClient()`, возвращающий новый сокет для клиентского соединения при подключении.

**ThreadPool**  
Управляет пулом потоков, выполняющих основную работу по обработке клиентских запросов:
- При инициализации создаёт определённое число потоков.
- Хранит очередь задач (в данном случае, дескрипторы клиентских сокетов).
- Потоки ожидают задание. Когда поступает новый клиентский fd, поток берёт его из очереди и обрабатывает:
    1. Считывает HTTP-запрос.
    2. Использует `HttpParser` для парсинга запроса.
    3. Если метод GET, вызывает `ConnectionHandler` для подключения к целевому серверу.
    4. Получает ответ от сервера, возвращает его клиенту.
    5. Закрывает клиентское соединение.
- При завершении работы (graceful shutdown) все потоки останавливаются после обработки текущих заданий.

**HttpParser**  
Простой HTTP-парсер:
- На вход получает строку с HTTP-запросом.
- Извлекает метод, путь, версию протокола и заголовки.
- Результат парсинга возвращается в структуре `HttpRequest`.

**ConnectionHandler**  
Отвечает за взаимодействие с целевым сервером:
- Получает распарсенный `HttpRequest`.
- Определяет хост, порт и путь к ресурсу. Поддерживает как относительные пути при наличии заголовка Host, так и полные URL (например, `http://example.com/path`).
- Устанавливает TCP-соединение с целевым сервером (`connect()`).
- Отправляет HTTP-запрос (в формате HTTP/1.0).
- Считывает ответ сервера.
- Обрабатывает перенаправления (3xx): если ответ — редирект, извлекает `Location`, формирует новый запрос и повторно обращается к новому адресу (ограниченное число попыток).
- Возвращает итоговый HTTP-ответ для отправки клиенту.

**SignalHandler**  
Обрабатывает сигналы (SIGINT, SIGTERM):
- При инициализации регистрирует обработчики сигналов.
- При получении сигнала устанавливает флаг завершения.
- `ProxyApp` и другие компоненты периодически проверяют этот флаг, чтобы начать корректное завершение.

**Logger**  
Предоставляет потокобезопасный вывод логов:
- Методы `info()` и `error()` синхронизируют доступ к стандартным потокам вывода.
- Позволяет видеть пошаговое выполнение запросов и отладку.

**Config**  
Хранит параметры конфигурации:
- Порт, на котором слушает прокси.
- Количество потоков в пуле.
- Может расширяться при необходимости другими настройками.

**Utils**  
Вспомогательные функции:
- `trim` для удаления пробелов в начале и конце строки.
- `parseUrl` для разбора полных URL на схему, хост, порт, путь.

Все эти классы вместе образуют архитектуру, в которой `ProxyApp` управляет жизненным циклом прокси-сервера, `Listener` принимает подключения, `ThreadPool` обрабатывает их в фоновом режиме, `HttpParser` и `ConnectionHandler` заботятся о корректном HTTP-взаимодействии, `SignalHandler` отвечает за плавное завершение, а `Logger` и `Utils` обеспечивают удобство и надёжность работы.  
